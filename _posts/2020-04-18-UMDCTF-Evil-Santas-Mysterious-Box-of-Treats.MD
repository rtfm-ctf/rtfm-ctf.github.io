---
layout: post
title: Write Up UMDCTF 2020 - Evil Santa's Mysterious Box of Treats (400pts)
description: Challenge Evil Santa's Mysterious Box of Treats
keywords: UDMCTF, reversing
tags: [UMDCTF]
---

* **CTF:** UMDCTF 2020
* **Challenge:** Challenge Evil Santa's Mysterious Box of Treats
* **Category:** Rev
* **Author:** WittsEnd2
* **Solved by:** RTFM[meli0das] 


# Challenge
> üéÖ has gone ü•ú!
> 
> He decided to make it impossible to get it into his üì¶, and if we don't get in, we will be receiving coal for the next üíØ years!
> 
> Help us figure out how to get into the üì¶ !
>
> Author: WittsEnd2






## [ 0x0 - Conhecendo o programa ]

Primeiro, verificar se realmente √© um bin√°rio...

```
root@kali:~/Downloads# file EvilSantasBox 
EvilSantasBox: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), for GNU/Linux 3.2.0, BuildID[sha1]=e22c231ce9e73f39af223ed5d5284d20d77aeb89, statically linked, no section header
```

Identificado como ELF 64bits :)

Ap√≥s executar e tentar qualquer input, obtemos o seguinte resultado.

```
root@kali:~/Downloads# ./EvilSantasBox 
-----------------------------------------
|                                       |
|                                       |
|                                       |
|         Evil Santa's Mysterious       |
|             Box of Treats             |
|                                       |
|                                       |
|                                       |
|                                       |
|                                       |
-----------------------------------------
Enter code here: 1234567890
You are getting coal for the next five years!
root@kali:~/Downloads# 
```



## [ 0x1 - Pre-debug ]

Como eu prefiro tudo nas telinhas do windows, vamos preparar para o remote debug com IDA :)

Basicamente eu...
```
1 - Copio o arquivo linux_server64 que est√° na pasta do IDA;
2 - Deixo na pasta onde meu ELF ser√° debugado;
3 - Executo o ./linux_server64;
4 - Copio o ELF para o windows;
5 - Abro o ELF no IDA;
6 - Configuro o IDA para acessar o linux;
7 - Pronto, so debugar!
```

PS .: Para uma explicacao melhor (https://www.hex-rays.com/products/ida/support/freefiles/remotedbg.pdf)

Tudo configurado, let's go!

## [ 0x2 - An√°lise ]

Bin√°rio carregado no IDA, para ver as strigs **SHIFT+F12**.

Logo de cara vemos o que interessa :)

![ida](../assets/imgs/01-ida-strings.PNG "Strings no IDA")

Adiantando um pouco as coisas, a mensagem: **Santa really doesn't like this. You are getting coal from now on!** √© identificada quando a aplica√ß√£o est√° rodando sobre um debuger, o famoso anti-debug.

Para n√£o pular e dar essa mensagem, basta - em runtime - modificar o salto [js](https://www.aldeid.com/wiki/X86-assembly/Instructions/js) mudando a eflag [SF](https://www.aldeid.com/wiki/X86-assembly/Registers#SF_.28Sign_Flag.29)
 para **0** que segue a compara√ß√£o sem executar o trecho abaixo.


![salto](../assets/imgs/02-salto-anti-debug.PNG "Salto anti-debug")



Ap√≥s analisar est√°ticamente e din√¢micamente, o tamanho que ele espera para o de c√≥digo de entrada, deve ser 40(decimal). O meu c√≥digo foi: **ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn**

Logo em seguida o programa printa uma informa√ß√£o importante na tela.

```
root@kali:~/Downloads# ./EvilSantasBox
-----------------------------------------
|                                       |
|                                       |
|                                       |
|         Evil Santa's Mysterious       |
|             Box of Treats             |
|                                       |
|                                       |
|                                       |
|                                       |
|                                       |
-----------------------------------------
Enter code here: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn

EDGFIHKJMLONQPSRUTWVYX[Z]\edgfihkjmlonqp
```

E uma parte importante do c√≥digo √© onde ele compara a string printada na tela - que √© o c√≥digo que eu digitei com algumas modifica√ß√µes - com uma string em hardcode no bin√°rio, essa compara√ß√£o √© feita na imagem abaixo.

![chave](../assets/imgs/03-compara-codigo.png "Compara c√≥digo de entrada")

Na imagem acima √© poss√≠vel ver o registrador **r11** com o valor **0x45** que √© igual a **69 decimal** e tamb√©m √© igual a letra **E** em ASCII, letra ao qual come√ßa a strings gerada pelo programa - meu c√≥digo digitado, por√©m, alterado.

Ao final dessas compara√ß√µes a string que deve ser gerada √© essa: **XY5IU5TKNZvV][92PX:5Q[9YZ5Ts]XThQ7]zVJ2A**


## [ 0x3 - C√≥digo e bandeira ]

Fiz alguns outros testes de input e eles foram:

```
Minha entrada:			ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn
Codigo gerado:			EDGFIHKJMLONQPSRUTWVYX[Z]\edgfihkjmlonqp

Minha entrada 2:		ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcd
Codigo gerado 2:		EDGFIHKJMLONQPSRUTWVYX[Z]\547698;:=2edgf

Minha entrada 3:		abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMN
Codigo gerado 3:		edgfihkjmlonqpsrutwvyx{z}|EDGFIHKJMLONQP
```

Basicamente o que entendi foi que:
- Se for **√≠mpar** soma 4.
- Se for **par** soma 2.

Como? Bom, al√©m do assembly, se olharmos as entradas e c√≥digo gerados acima, identificamos isso.

- A(65 decimal) + 4 = 69 decimal = **E**
- B(66 decimal) + 2 = 68 decimal = **D**
- C(67 decimal) + 4 = 71 decimal = **G**
- D(68 decimal) + 2 = 70 decimal = **F**

E assim sucessivamente...
 
Para validar, fiz esse script em python.
```
#!/bin/bash

keyCrypt="XY5IU5TKNZvV][92PX:5Q[9YZ5Ts]XThQ7]zVJ2A"
resultKey=""

for i in range(len(keyCrypt)):
    if ord(keyCrypt[i]) % 2 != 0:
        resultKey=resultKey+chr(ord(keyCrypt[i])-4)
    else:
        resultKey=resultKey+chr(ord(keyCrypt[i])-2)

print resultKey
```

Ap√≥s executar o script, obtenho a string: **VU1EQ1RGLXtTYW50NV81MW5UX1RoYVRfM3YxTH0=**

Como essa strings n√£o tem cara de flag, tentei decodar com base64, e...

```
root@kali:~# echo VU1EQ1RGLXtTYW50NV81MW5UX1RoYVRfM3YxTH0= | base64 --decode
UMDCTF-{Sant5_51nT_ThaT_3v1L}

```

Well done! ;)
